module Numeric.InfBackprop.Differentiable where

import Numeric.InfBackprop.DFunc (DLens(MkDLens), pullback, tupleToLens, tripleToLens, unpackLensD)
import Numeric.InfBackprop.Tangent (Tangent1, Dual, CT, T1, LongVec, Tangent)
import GHC.Base (Type, const, undefined, (==), ($), (.), fmap)
import NumHask (Multiplicative, one, Additive, zero, Distributive, (+))
import qualified Data.Vector.Generic.Sized as DVGS
import qualified Data.Vector.Generic as DVG
import qualified Data.Vector as DV
import qualified Data.Vector.Fixed.Boxed as DVFB
import qualified Data.Vector.Fixed as DVF
import GHC.TypeNats (KnownNat)
import Data.Finite (Finite)
import Data.Foldable (foldl')
import Control.Composition ((&))
import Data.Type.Equality (type (~))


class Differentiable a where
  type ArgField a :: Type
  -- type Out a b :: Type

  diff :: a -> ArgField a -> T1 a (CT a)
--  diff y t =

--  one1 :: a -> Field a -> Out a


instance Multiplicative ca => Differentiable (DLens ct t ca a) where
  type ArgField (DLens ct t ca a) = t
  -- type Out (DLens ct t ca a) = ct

--  one1 :: DLens ct t ca a -> t -> ct
--  one1 lens = pullback lens (const one)


-- Tuples

instance forall ct t ca0 ca1 a0 a1. (Distributive ca0, Distributive ca1) =>
  Differentiable (DLens ct t ca0 a0, DLens ct t ca1 a1) where
    type ArgField (DLens ct t ca0 a0, DLens ct t ca1 a1) = t
    -- type Out (DLens ct t ca0 a0, DLens ct t ca1 a1) = (ct, ct)

--    one1 :: (DLens ct t ca0 a0, DLens ct t ca1 a1) -> t -> (ct, ct)
--    one1 (lens0, lens1) x = (one1 lens0 x, one1 lens1 x)
--    one1 lensTuple x = let
--        bp c = pullback lens (const c) x
--        lens = tupleToLens lensTuple --  :: DLens ct t (ca0, ca2) (a0, a1)
--      in (bp (one, zero), bp (zero, one))

--instance forall a0 a1. (
--    Differentiable a0,
--    Differentiable a1,
--    Field a0 ~ Field a1
--  ) =>
--  Differentiable (a0, a1) where
--    type Field (a0, a1) = Field a0
--    type Out (a0, a1) = (Out a0, Out a1)
--
--    -- one1 a0 :: a0 -> Field a0 -> Out a0
--    -- one1 a1 :: a1 -> Field a1 -> Out a1
--    one1 :: (a0, a1) -> Field a0 -> (Out a0, Out a1)
--    one1 (y0, y1) x = let
--        outa0 = one1 y0 x
--        outa1 = one1 y1 x
--
--      in (bp (one, zero), bp (zero, one))


instance forall ct t ca0 ca1 ca2 a0 a1 a2. (
    Distributive ca0,
    Distributive ca1,
    Distributive ca2
--    Additive ct
  ) =>
  Differentiable (DLens ct t ca0 a0, DLens ct t ca1 a1, DLens ct t ca2 a2) where
    type ArgField (DLens ct t ca0 a0, DLens ct t ca1 a1, DLens ct t ca2 a2) = t
    -- type Out (DLens ct t ca0 a0, DLens ct t ca1 a1, DLens ct t ca2 a2) = (ct, ct, ct)

--    one1 :: (DLens ct t ca0 a0, DLens ct t ca1 a1, DLens ct t ca2 a2) -> t -> (ct, ct, ct)
--    one1 (lens0, lens1, lens2) x = (one1 lens0 x, one1 lens1 x, one1 lens2 x)
--    one1 lensTriple x = let
--        bp c = pullback lens (const c) x
--        lens = tripleToLens lensTriple
--      in (bp (one, zero, zero), bp (zero, one, zero), bp (zero, zero, one))


-- LongVec

longVecSum :: Additive a => LongVec n a -> a
longVecSum = foldl' (+) zero

longVecToLens :: forall n ct t ca a. Additive ct =>
  LongVec n (DLens ct t ca a) -> DLens ct t (LongVec n ca) (LongVec n a)
longVecToLens vec = MkDLens $ \t -> let
    (x, dxt) = DVGS.unzip $ fmap ((t &) . unpackLensD) vec :: (LongVec n a, LongVec n (ca -> ct))
  in (x, longVecSum . DVGS.zipWith ($) dxt)

longVecBasis :: (DVG.Vector v a, KnownNat n) =>
  Finite n -> a -> a -> DVGS.Vector v n a
longVecBasis k zero' one' = DVGS.generate $ \l ->
  if k == l
    then one'
    else zero'

--instance (
--    -- KnownNat n,
--    Distributive ca
--  ) =>
--  Differentiable (LongVec n (DLens ct t ca a)) where
--    type ArgField (LongVec n (DLens ct t ca a)) = t
--    type Out (LongVec n (DLens ct t ca a)) = LongVec n ct

--    one1 :: LongVec n (DLens ct t ca a) -> t -> LongVec n ct
--    one1 vecOfLens x = fmap (`one1` x) vecOfLens
--    one1 vecOfLens x = DVGS.generate bpk where
--      bpk = bp . basis
--      bp c = pullback lensOfVec (const c) x
--      lensOfVec = longVecToLens vecOfLens
--      basis k = longVecBasis k zero one :: LongVec n ca

--instance Differentiable a => Differentiable (LongVec n a) where


instance (
    -- KnownNat n,
    Differentiable a
--    Distributive ca
  ) =>
  Differentiable (LongVec n a) where
    type ArgField (LongVec n a) = ArgField a
--    type Out0 a (LongVec n a) = Out0 a (LongVec n b)
--    type Out1 (LongVec n a) b = LongVec n (Out1 a b)
    
    --   diff :: a -> ArgField a -> T1 a (CT a)
    diff :: LongVec n a -> ArgField a -> T1 (LongVec n a) (LongVec n (CT a))
    diff vec t = undefined where
      temp = fmap (`diff` t) vec :: LongVec n (T1 a (CT a))
    
    

instance (Distributive ca0, Distributive ca1) =>
  Differentiable (LongVec n0 (DLens ct t ca0 a0), LongVec n1 (DLens ct t ca1 a1)) where
    type ArgField (LongVec n0 (DLens ct t ca0 a0), LongVec n1 (DLens ct t ca1 a1)) = t
    -- type Out (LongVec n0 (DLens ct t ca0 a0), LongVec n1 (DLens ct t ca1 a1)) = (LongVec n0 ct, LongVec n1 ct)

--    diff ::
--      (LongVec n0 (DLens ct t ca0 a0), LongVec n1 (DLens ct t ca1 a1)) ->
--      t ->
--      T1 
--    diff tupleOfVecOfLens = undefined

--    one1 ::
--      (LongVec n0 (DLens ct t ca0 a0), LongVec n1 (DLens ct t ca1 a1)) ->
--      t ->
--      (LongVec n0 ct, LongVec n1 ct)
--    one1 (vecOfLens0, vecOfLens1) x = (one1 vecOfLens0 x, one1 vecOfLens1 x) -- let
--        vecCt0 = one1 vecOfLens0 x :: LongVec n0 ct
--        vecCt1 = one1 vecOfLens1 x :: LongVec n1 ct
--
--      in (bp (one, zero), bp (zero, one))

