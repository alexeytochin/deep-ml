{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE TypeOperators #-}

module InfBackprop.Common3 where

import Prelude ((.), id, fst, snd, uncurry, curry, ($), undefined, const)
import qualified Prelude as P
import NumHask ((*), (+), sin, cos, Additive, zero, Multiplicative, one, ExpField, exp, log, (**), Subtractive, negate, (-),
  Divisive, recip, Field, sinh, cosh, AdditiveAction, (^), (^^), TrigField, two, Distributive, Integral)
-- import NumHask (MultiplicativeAction, (.*))
import Data.Bifunctor (bimap)
import GHC.Base (Type)
import NumHask.Prelude (Float)
import Data.Void (Void, absurd)
import Data.Profunctor.Extra (Outer, (***), outer)
import Data.Profunctor (Profunctor, dimap, Strong, first', second', Costrong, unfirst, unsecond)
import Debug.SimpleExpr.Expr (number)


-- | Multiplicative Action
class MultiplicativeAction a b c | a b -> c where
  infixl 7 ..*
  (..*) :: a -> b -> c


--instance Additive (Float, Float)  where
--  (a, b) + (c, d) = (a + b, c + d)


instance (Additive a, Additive b) =>
  Additive (a, b)  where
    (a, b) + (c, d) = (a + c, b + d)
    zero = (zero, zero)

instance (Multiplicative a, Multiplicative b) =>
  Multiplicative (a, b)  where
    (a, b) * (c, d) = (a * c, b * d)
    one = (one, one)

--instance MultiplicativeAction (Float, Float) Float where
--  a .* (b, c) = (a .* b, a .* c)

instance (MultiplicativeAction a b1 c1, MultiplicativeAction a b2 c2) => MultiplicativeAction a (b1, b2) (c1, c2) where
  a ..* (b1, b2) = (a ..* b1, a ..* b2)

 
cross :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
cross f g (x, y) = (f x, g y)

fork :: (t -> a) -> (t -> b) -> t -> (a, b)
fork f g x = (f x, g x)


--instance Profunctor

--data A x y
--type B y x = A x y

data D dx x dy y  = D {
  view    :: x -> y,
  update  :: x -> dy -> dx
}

(%) :: D dy y dz z -> D dx x dy y -> D dx x dz z
(D v2 u2) % (D v1 u1) = D (v2 . v1) (\x dz -> u1 x (u2 (v1 x) dz))


--xxx :: D dx1 x1 dy1 y1 -> D dx2 x2 dy2 y2 ->

instance Profunctor (D dx x) where
--  dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
  dimap :: (dz -> dy) -> (y -> z) -> D dx x dy y -> D dx x dz z
  dimap f g (D v u) = D (g . v) (\x dz -> u x (f dz)) 


--instance (Profunctor p1, Profunctor p2) => Profunctor (p1 )

instance Costrong (D dt t) where
  -- unfirst  :: p (a, d) (b, d) -> p a b
  unfirst :: D dt t (dx, a) (x, a) -> D dt t dx x
  unfirst (D v u) = D (fst . v) (\t dx -> u t (dx, snd (v t)))
--  first' (D v u) = D (v . fst) (fork (u . cross id fst) (snd . snd))
--  second' (D v u) = D (v . snd) (fork (fst . snd) (u . cross id snd))

--type DP a b s t = forall p. Strong p => p a b -> p s t
--lensCtoP :: D y dy x dx -> DP y dy x dx
--lensCtoP (D v u) = dimap (fork v id) u . first'

class Splitable p where
  fst' :: Additive a2 => p (a1, a2) (b1, b2) -> p a1 b1
  snd' :: Additive a1 => p (a1, a2) (b1, b2) -> p a2 b2

instance Splitable (->) where
  fst' f = \a -> fst (f (a, zero))
  snd' f = \a -> snd (f (zero, a))

instance Splitable (D dx x) where
  fst' (D v u) = D (fst . v) (\x dy1 -> u x (dy1, zero))
  snd' (D v u) = D (snd . v) (\x dy2 -> u x (zero, dy2))

--class UnCurry a b d where -- | a b d -> c
--  uncurry2 :: (a -> b -> c) -> d -> c
--
--instance UnCurry a b (a, b) where
--  uncurry2 = uncurry
--
--instance (Additive dy1, Additive dy2) =>
--  UnCurry (D dx x dy1 y1) (D dx x dy2 y2) (D dx x (dy1, dy2) (y1, y2)) where
--    uncurry2 f (D v u) = f (D (fst . v) (\x dy1 -> u x (dy1, zero))) (D (snd . v) (\x dy2 -> u x (zero, dy2)))

--uncurry2 :: (D dx x dy1 y1, D dx x dy2 y2) -> D dx x (dy1, dy2) (y1, y2)
--uncurry2 f (D v u) = f (D (fst . v) (\x dy1 -> u x (dy1, zero))) (D (snd . v) (\x dy2 -> u x (zero, dy2)))
--instance (Splitable p, Additive dy1, Additive dy2) =>
--  UnCurry (p dy1 y1) (p dy2 y2) c (p (dy1, dy2) (y1, y2)) where
--    uncurry2 f x = f (fst' x) (snd' x)

--xxx :: (Additive dy, Additive dt, MultiplicativeAction y dt dt, Multiplicative y) =>
--  D dt t (dy, dy) (y, y) -> D dt t dy y
--xxx = uncurry2 (*)

--example_5_0 = derivative0 (uncurry2 (*) . toD) ((1.0, 2.0) :: (Float, Float)) -- :: Float
----example_5_1 = derivative1 (uncurry2 (*) :: D (Float, Float) (Float, Float) (Float, Float) (Float, Float) -> D (Float, Float) (Float, Float) (Float) (Float)) ((1.0, 2.0) :: (Float, Float)) :: (Float, Float)
----example_5_1_0 = derivative1 (xxx) ((1.0, 2.0) :: (Float, Float)) -- :: (Float, Float)
----example_5_2_0 = derivative2 (xxx) ((1.0, 2.0) :: (Float, Float)) -- :: (Float, Float)
--example_5_1 = derivative1 (uncurry2 (*) . toD) ((1.0, 2.0) :: (Float, Float)) -- :: (Float, Float)
--example_5_2 = derivative2 (uncurry2 (*) . toD) ((1.0, 2.0) :: (Float, Float)) :: ((Float, Float), (Float, Float))

--example_5_2 = derivative2 (uncurry2 (*)) ((1.0, 2.0) :: (Float, Float)) :: ((Float, Float), (Float, Float))

--class Convertable a b | a -> b where
--  convert :: b -> a
--  
--instance Convertable (D dx x dy y) (D dx x dy y) where
--  convert = id
--  
----instance (Additive dy1, Additive dy2) => 
----  Lensable (D dx x dy1 y1, D dx x dy2 y2) (D dx x (dy1, dy2) (y1, y2)) where
----    convert = merge
--
--instance (Additive dy1, Additive dy2, Convertable a (D dx x dy1 y1), Convertable b (D dx x dy2 y2)) => 
--  Convertable (a, b) (D dx x (dy1, dy2) (y1, y2)) where
--    convert = bimap convert convert . merge

type DP dx x dy y = forall p. Costrong p => p dx x -> p dy y

identity :: D a b a b
identity = D id (const id)

lensCtoP :: D dx x dy y -> DP dx x dy y
lensCtoP (D v u) = unsecond . dimap (uncurry u) (fork id v)

lensPtoC :: DP dx x dy y -> D dx x dy y
lensPtoC f = f identity


instance (Additive y, Additive dx) =>
  Additive (D dx x dy y) where
    zero = D (const zero) (const zero)
    (D v1 u1) + (D v2 u2) = D (\x -> v1 x + v2 x) (\t -> u1 t + u2 t)

instance (Subtractive a, Subtractive b) =>
  Subtractive (a, b) where
    negate = cross negate negate
    (a, b) - (c, d) = (a - c, b - d)

instance (Subtractive y, Subtractive dx) => 
  Subtractive (D dx x dy y) where
    negate (D v u) = D (negate v) (negate u)
    (D v1 u1) - (D v2 u2) = D (\x -> v1 x - v2 x) (\t -> u1 t - u2 t)

instance (MultiplicativeAction y dx dx, Additive dx, Multiplicative y) => 
  MultiplicativeAction (D dx x dy y) (D dx x dy y) (D dx x dy y) where
    D v1 u1 ..* D v2 u2 = D (\x -> v1 x * v2 x) (\x dy -> v2 x ..* u1 x dy + v1 x ..* u2 x dy)

instance (MultiplicativeAction y dx dx, Additive dx, Multiplicative y) => 
  Multiplicative (D dx x dy y) where
    one = D (const one) (const zero)
    (D v1 u1) * (D v2 u2) = D (\x -> v1 x * v2 x) (\x dy -> v2 x ..* u1 x dy + v1 x ..* u2 x dy)

instance (Distributive a, Distributive b) =>
  Distributive (a, b)

instance (Distributive y, Distributive dx, MultiplicativeAction y dx dx) =>
  Distributive (D dx x dy y) where


constC :: Additive dx => y -> D dx x dy y
constC c = D (const c) (const zero)

class Const a b where
  const_ :: a -> b
  
instance Const a a where
  const_ = id

instance (Additive dx, Const y1 y2) => Const y1 (D dx x dy y2) where
  const_ = constC . const_

addFirstArg :: Additive dc => D dx x dy y -> D (dc, dx) (c, x) dy y
addFirstArg (D v u) = D (v . snd) (\(_, x) dy -> (zero, u x dy))

addSecondArg :: Additive dc => D dx x dy y -> D (dx, dc) (x, c) dy y
addSecondArg (D v u) = D (v . fst) (\(x, _) dy -> (u x dy, zero))


class Differentiable x dx | x -> dx where
  startBackprop :: x -> dx

instance Differentiable Float Float where
  startBackprop = const 1

--instance (Differentiable a1 da1, Differentiable a2 da2) =>
--  Differentiable (a1, a2) ((da1, da2), (da1, da2)) where
--    startBackprop = \(x1, x2) -> ((startBackprop x1, zero), (startBackprop x1, zero))

instance (Differentiable a1 da1, Differentiable a2 da2, Differentiable a3 da3) =>
  Differentiable (a1, a2, a3) (da1, da2, da3) where
    startBackprop = \(x1, x2, x3) -> (startBackprop x1, startBackprop x2, startBackprop x3)

instance (Additive dx, MultiplicativeAction y dx dx, Multiplicative y) => -- MultiplicativeAction dx y, 
  Differentiable (D dx x dy y) (D dx x dy y) where
    startBackprop = const one

--instance (Multiplicative a) => Differentiable a a where
--  startBackprop = const one

--instance (Multiplicative a, a ~ b) => Differentiable a b where
--  startBackprop = const one

--class Differentiable x where
--  startBackprop :: x -> DD x
--  -- type DD x
--
--instance Differentiable Float where
--  startBackprop = const 1.
--  -- type DD Float = Float

type Hat y dy = y -> dy

scalarHat :: Multiplicative y =>
  Hat y y
scalarHat = const one

tupleHat :: (Multiplicative a, Multiplicative b, Additive a, Additive b) =>
  Hat (a, b) ((a, b), (a, b))
tupleHat = const ((one, zero), (zero, one))

tuple3Hat :: (Multiplicative a, Multiplicative b, Multiplicative c, Additive a, Additive b, Additive c) =>
  Hat (a, b, c) ((a, b, c), (a, b, c), (a, b, c))
tuple3Hat = const ((one, zero, zero), (zero, one, zero), (zero, zero, one))

endLens :: Multiplicative dx =>
  D dx x () x
endLens = D id (const one)

tupleLens :: (Multiplicative dx1, Multiplicative dx2, Additive dx1, Additive dx2) =>
  D ((dx1, dx1), (dx2, dx2)) (x1, x2) () (x1, x2)
tupleLens = D id (\_ _ -> ((one, zero), (zero, one)))

tuple3Lens :: (Multiplicative dx1, Multiplicative dx2, Multiplicative dx3, Additive dx1, Additive dx2, Additive dx3) =>
  D ((dx1, dx1, dx1), (dx2, dx2, dx2), (dx3, dx3, dx3)) (x1, x2, x3) () (x1, x2, x3)
tuple3Lens = D id (\_ _ -> ((one, zero, zero), (zero, one, zero), (zero, zero, one)))




derivativeC :: -- Differentiable y dy =>
  Hat y dy -> D dx x dy y -> x -> dx
derivativeC h l x = update l x (h (view l x))


derivative :: -- Differentiable y dy =>
  Hat y dy -> (D dx x dx x -> D dx x dy y) -> x -> dx
derivative h f = derivativeC h (f identity)

--derivative_2 :: (Differentiable y dy, Additive dx1, Additive dx2) =>
--  ((D (dx1, dx2) (x1, x2) dx1 x1, D (dx1, dx2) (x1, x2) dx2 x2) -> D (dx1, dx2) (x1, x2) dy y)
--  -> (x1, x2)
--  -> (dx1, dx2)
--derivative_2 f = derivative (f . lensToTuple) -- undefined -- derivative (crossC2)  -- derivativeC (f (identity, identity))

--xxx :: (Additive dy, Additive dt, MultiplicativeAction y dt dt, Multiplicative y) => 
--  D dt t (dy, dy) (y, y) -> D dt t dy y
--xxx = uncurry2 (*)

--derivative_ :: forall dx x dy y. (Differentiable y dy) =>
--  DP dx x dy y -> x -> dx
----derivative_ f = derivativeC (lensPtoC (f :: DP dx x dy y) :: D dx x dy y) :: x -> dx
--derivative_ f = derivativeC (lensPtoC f)


derivative0 ::
  (x -> dx) -> x -> dx
derivative0 = id

derivative1 :: -- Differentiable y dy =>
  Hat y dy -> (D dx x dx x -> D dx x dy y) -> x -> dx
derivative1 = derivative

--derivative2 :: (Differentiable u du_) =>
--  (D (D du_ u du_ u) (D du_ u dx x) (D du_ u du_ u) (D du_ u dx x) -> D (D du_ u du_ u) (D du_ u dx x) dy y) -> x -> dx
--derivative2 :: -- forall dx x dy0 y0 dy1 y1. (Differentiable y0 dy0, Differentiable y1 dy1) =>
--  (D (D dx x dy0 y0) (D dx x dx x) (D dx x dy0 y0) (D dx x dx x) -> D (D dx x dy0 y0) (D dx x dx x) dy1 y1) -> x -> dx
--derivative2 = derivative . derivative


-- (D du_ u dx x) (D du_ u du_ u)


squareC :: (Additive x, MultiplicativeAction x dx dx, Multiplicative x) =>
  D dx x dx x
squareC = D (\x -> x * x) (\x dy -> two * x ..* dy)

square :: (Additive x, MultiplicativeAction x dx dx, Multiplicative x) =>
  DP dx x dx x
square = lensCtoP squareC

recipC :: (Divisive x, MultiplicativeAction x dx dx, Subtractive dx) =>
  D dx x dx x
recipC = D recip (\x dy -> negate $ recip x^2 ..* dy)

instance (Divisive a, Divisive b) =>
  Divisive (a, b) where
    recip = cross recip recip

instance (Divisive x, MultiplicativeAction x dt dt, MultiplicativeAction x dx dx, Subtractive dx, Additive dt) =>
  Divisive (D dt t dx x) where
    recip = lensCtoP recipC

instance (Field a, Field b) =>
  Field (a, b)

instance (Divisive x, MultiplicativeAction x dx dx, MultiplicativeAction x dt dt, Distributive x, Subtractive dx, Subtractive x, Distributive dt, Subtractive dt) =>
  Field (D dt t dx x) where

expC :: (ExpField x, MultiplicativeAction x dx dx) =>
  D dx x dx x
expC = D exp (\x dy -> exp x ..* dy)

logC :: (ExpField x, MultiplicativeAction x dx dx) =>
  D dx x dx x
logC = D log (\x dy -> recip x ..* dy)

instance (ExpField x, MultiplicativeAction x dx dx, Distributive dx, Subtractive dx) =>
  ExpField (D dx x dx x) where
    exp = lensCtoP expC
--  exp (D v u) = D expV (\(dy, x) -> u (dy * expV x, x)) where
--    expV = exp . v
--  log (D v u) = D (log . v) (\(dy, x) -> u (dy / x, x))
    log = lensCtoP logC
    (**) = undefined -- :: a -> a -> a

sinhC :: (TrigField x, MultiplicativeAction x dx dx) => D dx x dx x
sinhC = D sinh (\x dy -> cosh x ..* dy)
coshC :: (TrigField x, MultiplicativeAction x dx dx) => D dx x dx x
coshC = D cosh (\x dy -> sinh x ..* dy)

instance (TrigField a, TrigField b) =>
  TrigField (a, b) where
    sinh = cross sinh sinh
    cosh = cross cosh cosh


instance (TrigField x, MultiplicativeAction x dx dx, MultiplicativeAction x dt dt, Distributive dx, Subtractive dx, Distributive dt, Subtractive dt) =>
  TrigField (D dt t dx x) where
    sinh = lensCtoP sinhC
    cosh = lensCtoP coshC

crossC :: D y1 dy1 x1 dx1 -> D y2 dy2 x2 dx2 -> D (y1, y2) (dy1, dy2) (x1, x2) (dx1, dx2)
crossC (D v1 u1) (D v2 u2) =
  D (bimap v1 v2) (\(x1, x2) (dy1, dy2) -> (u1 x1 dy1, u2 x2 dy2))

crossC2 :: (D y1 dy1 x1 dx1, D y2 dy2 x2 dx2) -> D (y1, y2) (dy1, dy2) (x1, x2) (dx1, dx2)
crossC2 = uncurry crossC

--instance (Profunctor p) =>
--  Curry (p a1 b1) (p a2 b2) (p (a1, a2) (b1, b2)) where
--    uncurry2 :: ((p a1 b1) -> (p a2 b2) -> c) -> (p (a1, a2) (b1, b2)) -> c
--    uncurry2 f =
    -- uncurry2 f (D v u) = f (D (fst . v) (\x dy1 -> u x (dy1, zero))) (D (snd . v) (\x dy2 -> u x (zero, dy2)))

tupleToLens :: Additive dt =>
  (D dt t dx1 x1, D dt t dx2 x2) -> D dt t (dx1, dx2) (x1, x2)
tupleToLens (D v1 u1, D v2 u2) = D (\t -> (v1 t, v2 t)) (\t (dy1, dy2) -> u1 t dy1 + u2 t dy2)
-- crossC3 (D v1 u1) (D v2 u2) = D (fork v1 v2) ()

lensToTuple :: (Additive dx1, Additive dx2) =>
  D dt t (dx1, dx2) (x1, x2) -> (D dt t dx1 x1, D dt t dx2 x2)
lensToTuple (D v u) = (D (fst . v) (\t dy1 -> u t (dy1, zero)), D (snd . v) (\t dy2 -> u t (zero, dy2)))


merge :: (Additive dy1, Additive dy2) =>
  D dx x (dy1, dy2) (y1, y2) -> (D dx x dy1 y1, D dx x dy2 y2)
merge (D v u) = (
    D (fst . v) (\x dy1 -> u x (dy1, zero)), 
    D (snd . v) (\x dy2 -> u x (zero, dy2))
  )




multC :: (MultiplicativeAction x dx dx, Multiplicative x) =>
  D (dx, dx) (x, x) dx x
multC = D (uncurry (*)) (\(x1, x2) dy -> (x2 ..* dy, x1 ..* dy))

--mult :: (Multiplicative x) =>
--   (x, x) -> x
--mult = uncurry (*)


class Additive2 a b c where
  (.+.) :: a -> b -> c

instance Additive2 a b c
  => Additive2 (a) b c


--(.+.) :: forall t dt x dx. (Additive t) =>
--  D dx x dt t  -> D dx x dt t -> D (dx, dx) (x, x) dt t
--a .+. b = lensCtoP addC (crossC a b)

--class Multiplicative2 a where
--  (.*.) :: (a, a) -> a

(.*.) :: forall t dt x dx. (MultiplicativeAction t dt dt, Multiplicative t) =>
  D dx x dt t  -> D dx x dt t -> D (dx, dx) (x, x) dt t
a .*. b = lensCtoP multC (crossC a b)


instance MultiplicativeAction Float Float Float where
  (..*) = (*)


example_0_0 = derivative0 cosh (0.0 :: Float) :: Float
example_0_1 = derivative1 scalarHat cosh (0.0 :: Float) :: Float
-- example_0_2 = derivative2 cosh (0.0 :: Float) :: Float


--example_1 = derivative (\x -> const_ (2 :: Float) * cosh x) 0.0 :: Float
--example_2 = derivative2 (\x -> const_ (2 :: Float) * cosh x) 0.0 :: Float
example_3_0 = derivative0 (uncurry (+)) (1.0 :: Float, 2.0 :: Float)
example_3 = derivative scalarHat (\x -> x + x) (1.0 :: Float) :: Float
-- example_4 = derivative1 tupleHat (lensCtoP addC) ((1.0, 2.0) :: (Float, Float)) :: (Float, Float)

--example_3_1 = derivative_ (\x -> x + x) (1.0 :: Float) :: Float

-- example_5_0 = derivative_2 (uncurry (*)) ((1.0, 2.0) :: (Float, Float)) -- :: Float


class Sum a b | a -> b where -- | a -> b
  add :: a -> b

instance Additive a =>
  Sum (a, a) a where
    add :: (a, a) -> a
    add = uncurry (+)

instance (Sum a b, Split db da) =>
  Sum (D dt t da a) (D dt t db b) where
    add :: D dt t da a -> D dt t db b
    add (D v u) = D (add . v) (\t db -> u t (split db))


class Split a b | b -> a where -- | a -> b
  split :: a -> b

instance Split a (a, a) where
  split :: a -> (a, a)
  split = \x -> (x, x)

instance (Split a b, Sum db da) =>
  Split (D dt t da a) (D dt t db b) where
    split :: D dt t da a -> D dt t db b
    split (D v u) = D (split . v) (\t db -> u t (add db))


addC :: Additive x =>
  D (dx, dx) (x, x) dx x
addC = D (uncurry (+)) (\_ dx -> (dx, dx))

--addC2 :: Sum (x, x) x =>
--  D (dx, dx) (x, x) dx x
--addC2 = D add (\_ dx -> (dx, dx))





class Mult a b where -- | a -> b
  mult :: a -> b
  
instance Multiplicative a => Mult (a, a) a where
  mult :: (a, a) -> a
  mult = uncurry (*)

instance Mult a b => Mult (D dt t da a) (D dt t db b) where
  mult :: D dt t da a -> D dt t db b
  mult = undefined -- uncurry (*)

xxx :: (TrigField x, MultiplicativeAction x dx dx, MultiplicativeAction x dt dt, Distributive dx, Distributive dt, Subtractive dx, Subtractive dt) =>
  (D dt t dx x, D dt t dx x) -> (D dt t dx x, D dt t dx x)
xxx = cross sinh cosh

yyy :: (Additive x, Additive dt) => (D dt t dx x, D dt t dx x) -> D dt t dx x
yyy = uncurry (+)

--zzz :: D dt t dx2 x2 -> D dt t (dx2, dx2) (x2, x2)
--zzz = tupleToLens . (\x -> (x, x))

example_1_0 = derivative0 add ((1.0, 2.0) :: (Float, Float))
example_1_1 = derivative scalarHat add ((1.0, 2.0) :: (Float, Float)) :: (Float, Float)
example_1_2 = derivative scalarHat (uncurry (+) . lensToTuple) ((1.0, 2.0) :: (Float, Float)) :: (Float, Float) -- :: ((Float, Float), (Float, Float))
-- example_1_2_ = derivative (yyy. lensToTuple) ((1.0, 2.0) :: (Float, Float)) :: (Float, Float) -- :: ((Float, Float), (Float, Float))
example_1_3 = derivative tupleHat (tupleToLens . (\x -> (x, x)) ) (2.0 :: Float) :: (Float, Float) -- :: ((Float, Float), (Float, Float))
example_1_4 = derivative tupleHat (tupleToLens . xxx . lensToTuple) ((1.0, 2.0) :: (Float, Float)) :: ((Float, Float), (Float, Float)) -- :: (Float, Float) --
example_1_5 = derivative tupleHat (tupleToLens . cross sinh cosh . lensToTuple) ((1.0, 2.0) :: (Float, Float)) :: ((Float, Float), (Float, Float)) -- :: (Float, Float) -- :: ((Float, Float), (Float, Float))
-- example_1_6 = derivative tupleHat (tupleToLens . (\x -> ((x, x), (x, x)))) ((1.0, 2.0) :: (Float, Float)) --  :: ((Float, Float), (Float, Float)) -- :: (Float, Float) -- :: ((Float, Float), (Float, Float))

tupleToLens2 :: Additive dt =>
  ((D dt t dx11 x11, D dt t dx12 x12), (D dt t dx21 x21, D dt t dx22 x22)) -> D dt t ((dx11, dx12), (dx21, dx22)) ((x11, x12), (x21, x22))
tupleToLens2 = tupleToLens . bimap tupleToLens tupleToLens

--derivativeX :: (Multiplicative a, Multiplicative b, Additive dx1, Additive dx2) => 
--  ((D (dx1, dx2) (x1, x2) dx1 x1, D (dx1, dx2) (x1, x2) dx2 x2) -> (D (dx1, dx2) (x1, x2) (a, b) a, D (dx1, dx2) (x1, x2) (a, b) b)) -> 
--  (x1, x2) -> 
--  (dx1, dx2)
--derivativeX f = derivative tupleHat (tupleToLens . f . lensToTuple)
--example_1_6 = (derivative_x . derivative_x) (cross sinh cosh) ((1.0, 2.0) :: (Float, Float)) :: (Float, Float) -- :: (((Float, Float), (Float, Float)), ((Float, Float), (Float, Float))) -- :: (Float, Float) -- :: ((Float, Float), (Float, Float))


--example_2_2 = (derivative_2 (derivative_2 (uncurry (+)))) ((1.0, 2.0) :: (Float, Float)) :: ((Float, Float), (Float, Float)) -- :: (Float, Float) --


example_2_0 = derivative0 split 1.0 :: (Float, Float)


--example_5_0 = derivative0 (uncurry2 (*)) ((1.0, 2.0) :: (Float, Float)) -- :: Float
----example_5_1 = derivative1 (uncurry2 (*) :: D (Float, Float) (Float, Float) (Float, Float) (Float, Float) -> D (Float, Float) (Float, Float) (Float) (Float)) ((1.0, 2.0) :: (Float, Float)) :: (Float, Float)
--example_5_1_0 = derivative1 (xxx) ((1.0, 2.0) :: (Float, Float)) -- :: (Float, Float)
--example_5_1 = derivative1 (uncurry2 (*)) ((1.0, 2.0) :: (Float, Float)) -- :: (Float, Float)
----example_5_2 = derivative2 (uncurry2 (*)) ((1.0, 2.0) :: (Float, Float)) :: ((Float, Float), (Float, Float))

 -- (1.0 :: Float, 2.0 :: Float)